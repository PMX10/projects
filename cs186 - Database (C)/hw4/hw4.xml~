<?xml version="1.0" encoding="UTF-8"?>
<!--
UC Berkeley CS186 Database course
Assignment 4

Put your answers in blocks wrapped by "<![CDATA[" and "]]>". Each block is
marked with TODO. Remove the TODO after putting your answer in.

If the "autograde" attribute is "yes" for a question, the question will be
marked using a grading script. Make sure you follow the instructions on the
format for the answers.
-->
<assignment>

<!--
Question 1 SOME EASY STUFF

Connect to the database.  Type "\d" to see the list of relations in the
database.  Use SQL queries to examine these relations. In particular examine
the relation Rankings. Answer the following questions:
-->
<question id="1a" autograde="yes"
  text="What are the attributes of the Students relation?">
<![CDATA[
id, name, school
]]></question>

<question id="1b1" autograde="yes"
  text="How many indexes are built on the Rankings relation?">
<![CDATA[
2
]]></question>

<question id="1b2" autograde="yes"
  text="Name the indexes and write down their type?">
<![CDATA[
rankings_pkey, btree
gradrate_idx, btree
]]></question>

<question id="1c" autograde="yes"
  text="How many tuples are there in the Rankings relation?">
<![CDATA[
1302
]]></question>

<question id="1d" autograde="yes"
  text="How many distinct values of state does the query planner estimate there
       are for the Rankings relation?
       (hint: Query pg_stats to find out)">
<![CDATA[
51
]]></question>

<question id="1e" autograde="yes"
  text="How many distinct values of state are there actually in the rankings
        table? (hint: it's probably easiest to run a query to compute
        this!)">
<![CDATA[
51
]]></question>

<question id="1f"
  text="What query did you use to find the answer to E?">
<![CDATA[
select count(distinct R.state) from rankings R;
]]></question>
	
<!--
Question 2 USING THE QUERY PLAN VIEWER

This question requires you to use the PostgreSQL query plan visualization
command EXPLAIN. Read the documentation for EXPLAIN at the link given above.
Note that (like System R) EXPLAIN estimates query costs in units of disk I/Os
(CPU instructions are added in by multiplying times a conversion factor).
Consider the following query:

SELECT * FROM rankings WHERE state = 'CA'; 

Answer the following questions looking at the query plan generated by the
EXPLAIN command:
-->
<question id="2a"
  text="Briefly describe the plan chosen.">
<![CDATA[
Sequential scan is used. Since there are no other indexes in rankings table with the "state" attribute, sequential scan is the only and most optimal plan.
]]></question>

<question id="2b"
  text="In what order would the tuples be returned by this plan? Why?">
<![CDATA[
The order of the tuples would be returned by the same order as they listed in the ranking table. Because the query optimizer sequentially scans the rankings table from top to the bottom, and outputs the tuples matching the condition where state="CA" with the same order.
]]></question>

<question id="2c" autograde="yes"
  text="What is the estimated total cost of running the plan?">
<![CDATA[
48.27
]]></question>

<question id="2d"
  text="What is the estimated result cardinality for this plan? Looking at the
        statistics, why does the optimizer come up with this estimate?">
<![CDATA[
The estimated result cardinality is about 70. This number is based on the most_common_freqs corresponding to state = 'CA' in the pg_stats table, times the total number of tuples in 'ranking' table. 
]]></question>

<question id="2e" autograde="yes"
  text="How many colleges actually do have state = 'CA'?">
<![CDATA[
70
]]></question>

<question id="2f"
  text="Looking at the statistics, what are the top 5 states with the most
        colleges and the percentage of colleges in each of those state?">
<![CDATA[
NY, 7.7573%
PA, 6.37481%
CA, 5.37634%
TX, 4.6083%
MA, 4.30108%
]]></question>

<question id="2g"
  text="Which value of state is actually the most popular, and how many tuples
        have that state? How did you figure this out (what query did you use)?">
<![CDATA[
NY, 101
select rankings.state, count(rankings.state) as c from rankings group by rankings.state order by c desc limit 1; 
]]></question>

<!--
Question 3 SELECTS WITH INDEXES

Consider the same query from previous question: 

SELECT * FROM rankings WHERE state = 'CA'; 

Answer the following questions looking at the plans and the access methods:
-->
<question id="3a"
  text="Create a btree index on the attribute state of the relation Rankings.
        What is the plan chosen for the query now?">
<![CDATA[
Index Scan.
]]></question>

<question id="3b" autograde="yes"
  text="What is the estimated total cost of running the plan?">
<![CDATA[
45.20
]]></question>

<question id="3c"
  text="Compare this plan with the plan obtained in question 2.A above.
        Which is cheaper and why?">
<![CDATA[
Index scan is a cheaper than sequential scan. In part (a), we created a btree indexed by the attribute state. So now, instead of scanning through the entire "rankings" table finding the matching condition, the time could be reduced by searching in the indexed btree.
]]></question>

<!--
Question 4 RANGE SELECTS

DROP the index that you created for Question 3. Don't forget to VACUUM ANALYZE
Now analyze the query plan that PostgreSQL comes up for the following query: 

SELECT * FROM rankings WHERE gradrate < 10;

Answer the following questions:
-->
<question id="4a" autograde="yes"
  text="How many ranking tuples that have gradrate &lt; 10 does the
        optimizer think there are?">
<![CDATA[
2 
]]></question>

<question id="4b"
  text="In what order will the tuples be returned by this plan?">
<![CDATA[
The tuples are returned by ascending order. Since the query used index Scan using gradrate_idx on rankings, it proceeds the index tree from the left-most (smallest index) to right-most (largest index).
]]></question>

<question id="4c"
  text="What is a value of the constant (i.e. '10' in the above query) such
        that the optimizer chooses a different plan? What is that plan and why
        does the optimizer think it will be cheaper than the previous plan when
        used with this new constant?">
<![CDATA[
When gradrate<19, the optimizer changes the plan to sequential scan. Technically, index scan requires 4 steps, seek where index is, fetch page from the index, seek where table is and fetch page from the table. Whereas sequential scan is much easier, just seek where the table is in and fetch the page from table. Obviously, sequential scan requires much less disk head movements than index scan when scanning sequential data blocks, which means sequetial scan is much fast when fetching data is the next block. From this reason, we can argue that when fetching more than a certain percent of the page, sequential scan is more efficient, and the optimizer will changes the plan based on a certain efficient factor. 
]]></question>

<!--
Question 5 SIMPLE JOIN

Create a B-tree index on 'studentfacultyratio' of the rankings table.
Analyze the query plan for the following query that finds the average salary at
schools who have a student to faculty ratio < 5.

SELECT R.name, F.avesalary 
FROM rankings R, financials F
WHERE R.id = F.id AND R.studentfacultyratio < 5; 

Answer the following questions:
-->
<question id="5a"
  text="What is the estimated cost of this plan?">
<![CDATA[
73.49
]]></question>

<question id="5b" autograde="yes"
  text="What kind of join is used by the plan?">
<![CDATA[
Hash Join
]]></question>

<question id="5c1" autograde="yes"
  text="Disable the join type used in the above plan and re-optimize the query.
        What type of join is used now?">
<![CDATA[
Nested Loop Join
]]></question>

<question id="5c2" autograde="yes"
  text="And what is the total estimated cost of the query?">
<![CDATA[
90.86
]]></question>

<!--
Question 6 THREE-WAY JOIN

DROP the index that you created for Question 5, RE-ENABLE (using "SET") the join method you turned off above, Don't forget to VACUUM ANALYZE
Answer the following questions referring to the query below: 

SELECT S.name, R.name, F.avesalary
FROM students S, rankings R, financials F
WHERE S.school = R.id and R.id = F.id;
-->
<question id="6a"
  text="Describe the best plan estimated by the optimizer. List the joins and
        access methods it uses, and the order in which the relations are
        joined.">
<![CDATA[
The best plan estimated by the optimizer is hash join. 
Sequentially scans on students relation.
Hash students into buffer.
Sequentially scans the financial relation. 
Joins the two tables by using hash join with the hash condition "f.id=s.school".
Hash the joint table into the buffet.
Sequentially scans the rankings relation. 
Hash join the joint table and the rankings table with the hash condition "r.id = s.school".
]]></question>

<question id="6b"
  text="Modify the query by adding a condition R.studentfacultyratio &lt; 8.
        What is the relational algebra expression for the new join order?
        Why is this new join ordering better for the extended query than the
        ordering obtained in part A?">
<![CDATA[
students ⋈ [s.school=r.id] (financials ⋈ [f.id=r.id] (σ r.studentfacultyratio<8))
After the filtering condition "R.studentfacultyratio<8" was excuted, it reduced the size of the table which required to be joint with financials table. Thus, it also reduced the runtime in the rest of all joint process.
]]></question>

<!--
Question 7 SQL

Answer the following questions about the database (by writing queries!):
-->
<question id="7a" autograde="yes"
  text="What is the name of the public school (public = 1) with the highest
        average salary?">
<![CDATA[
Rutgers State Univ.-Newark
]]></question>

<question id="7b" autograde="yes"
  text="Find the public school (public = 1) with the largest difference
        between instate tuition and out of state tuition that has at least
        one student attending.">
<![CDATA[
Albany State College
]]></question>

<question id="7c"
  text="Show a query to find out some other interesting fact in the database
        and tell us what the answer is (or at least summarize it).">
<![CDATA[
TODO: Put your answer here and REMOVE THIS TODO.  
]]></question>

</assignment>
